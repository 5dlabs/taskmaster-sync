# Task ID: 20
# Title: Design and Implement Service-Based Task Organization for Monorepo Support
# Status: pending
# Dependencies: 5, 8, 10, 19
# Priority: medium
# Description: Enable Taskmaster to organize tasks by service context using tags, prefixes, or directory structure, and integrate with agent assignment based on service ownership. Implementation will leverage Rust's path handling and pattern matching capabilities for efficient service detection and use HashMap-based service context management.
# Details:
Implement a comprehensive service-based task organization system that supports monorepo development workflows using Rust-native approaches. The implementation should include: 1) Rust-Native Service Detection Engine - Create automatic service detection using std::path::Path and PathBuf for directory structure analysis, implement pattern matching with regex crate for service identification from folder hierarchy, use Rust's string pattern matching for task tag parsing to extract service context, leverage Path::file_name() and Path::parent() for filename/path prefix identification, and implement configuration-based service mapping using serde for deserialization. 2) HashMap-Based Service Context Manager - Build service metadata management using HashMap<String, ServiceConfig> for service ownership mapping, implement service-specific configuration inheritance with custom Rust structs, create cross-service dependency tracking using Vec<ServiceDependency>, and support service hierarchy with nested HashMap structures for parent-child relationships. 3) Enhanced Tag System Integration - Extend the existing tag system using Rust enums and pattern matching for service-specific tags, implement service tag inheritance using trait-based propagation, create service tag filtering with Iterator combinators and custom predicates, and support composite tags using custom ServiceTag enum variants. 4) Agent Assignment Integration - Integrate with Task 19's agent assignment system using Rust's type system for service-based assignment rules, implement service ownership to agent mapping with HashMap<ServiceId, AgentId>, support service-specific workload balancing using custom load balancing algorithms, and create fallback assignment strategies with Option<T> and Result<T, E> error handling. 5) Configuration Schema Extension - Extend sync-config.json using serde_json for service definitions with custom ServiceConfig struct, implement service-to-project mappings using HashMap collections, create service ownership configuration with Owner struct containing contact and responsibility fields, and add service-specific sync settings using nested configuration structures. 6) Monorepo Structure Support - Implement multi-service project synchronization using async/await with tokio for concurrent processing, support service-specific GitHub Projects with custom GitHub API integration, handle cross-service task dependencies using dependency graph structures, and provide service isolation options using Rust's module system and visibility controls.

# Test Strategy:
Create comprehensive test suite covering all service organization aspects using Rust testing framework: 1) Service Detection Testing - Test automatic service detection from various directory structures using std::fs and tempfile for test fixtures, validate tag-based service extraction with proptest for property-based testing of different tag formats, test prefix-based service identification using Path manipulation test cases, and verify configuration-based service mapping accuracy with serde_json deserialization tests. 2) Service Context Management Testing - Test service metadata storage and retrieval using HashMap operations and custom assertion helpers, validate service ownership mapping functionality with mock data structures, test cross-service dependency resolution using graph traversal algorithms, and verify service hierarchy handling with nested structure tests. 3) Integration Testing - Test integration with existing tag system (Task 10) using integration test modules, validate agent assignment integration (Task 19) with mock agent implementations, test configuration system extension (Task 5) using configuration file parsing tests, and verify core sync engine compatibility (Task 8) with end-to-end synchronization tests. 4) Monorepo Workflow Testing - Test multi-service project synchronization scenarios using async test frameworks like tokio-test, validate service-specific GitHub Project creation with GitHub API mocking, test cross-service task dependency handling using dependency injection patterns, and verify service isolation functionality with module boundary tests. 5) Performance Testing - Test service detection performance with large monorepos using criterion benchmarking crate, validate service filtering efficiency with performance profiling, test concurrent service synchronization using async benchmarks, and measure impact on existing sync performance with comparative benchmarking. 6) Edge Case Testing - Test handling of services without clear boundaries using error case testing, validate behavior with conflicting service detection methods using property-based testing, test service configuration migration scenarios with version compatibility tests, and verify graceful degradation when service detection fails using Result<T, E> error handling tests.
